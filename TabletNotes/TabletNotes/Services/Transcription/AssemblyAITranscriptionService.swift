import Foundation
import SwiftData
import SwiftUI
import Combine
import Supabase
// Temporary workaround for linter: define TranscriptSegment if not found
#if canImport(TabletNotes)
// If available, use the real model
#else
struct TranscriptSegment: Identifiable {
    var id = UUID()
    var text: String
    var startTime: TimeInterval
    var endTime: TimeInterval
    init(text: String, startTime: TimeInterval, endTime: TimeInterval) {
        self.text = text
        self.startTime = startTime
        self.endTime = endTime
    }
}
#endif
// import TabletNotes.TabletNotes.Models.Transcript // Uncomment if needed, but likely not needed if in same module

// Ensure TabletNotes/TabletNotes/Resources/AssemblyAIKey.swift and TabletNotes/TabletNotes/Models/Transcript.swift are included in the build target for AssemblyAIConfig and TranscriptSegment to be in scope.

// MARK: - Vercel API Models

// For /api/generate-upload-url
struct GenerateUploadURLResponse: Codable {
    let success: Bool
    let data: UploadURLData
    let timestamp: String
}

struct UploadURLData: Codable {
    let uploadUrl: String
    let path: String
    let token: String
    let userId: String
    let metadata: UploadMetadata?
}

struct UploadMetadata: Codable {
    let originalFileName: String
    let contentType: String
    let fileSize: Int
    let maxFileSize: Int
    let allowedTypes: [String]
}

// For /api/transcribe
// Based on transcribe.js, it returns a transcript-like object.
// The `segments` are actually words from AssemblyAI.
struct TranscribeResponse: Codable {
    let success: Bool
    let data: TranscribeData
    let timestamp: String
}

struct TranscribeData: Codable {
    let id: String
    let text: String?
    let segments: [AssemblyAIWord]? // 'segments' in my Vercel API is 'words' from AssemblyAI
    let status: String
    let userId: String?
}

struct AssemblyAIWord: Codable {
    let text: String
    let start: Int
    let end: Int
    let confidence: Double
    let speaker: String?
}

class AssemblyAITranscriptionService: ObservableObject {
    // API endpoints
    private let apiBaseUrl = "https://comfy-daffodil-7ecc55.netlify.app"
    private lazy var generateUploadUrlEndpoint = "\(apiBaseUrl)/api/generate-upload-url"
    private lazy var transcribeEndpoint = "\(apiBaseUrl)/api/transcribe"
    
    // Supabase client for authentication
    private let supabase: SupabaseClient
    
    init(supabase: SupabaseClient = SupabaseService.shared.client) {
        self.supabase = supabase
    }

    // 1. Get Upload URL from backend
    private func getUploadURL(fileName: String, contentType: String, fileSize: Int, completion: @escaping (Result<GenerateUploadURLResponse, Error>) -> Void) {
        print("[API] Getting upload URL for \(fileName)")
        
        Task {
            do {
                // Get authentication token
                let session = try await supabase.auth.session
                
                guard let url = URL(string: generateUploadUrlEndpoint) else {
                    completion(.failure(NSError(domain: "InvalidURL", code: 0, userInfo: nil)))
                    return
                }

                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
                let body = [
                    "fileName": fileName,
                    "contentType": contentType,
                    "fileSize": fileSize,
                    "filePath": "temp" // Placeholder - actual path is generated by function
                ] as [String : Any]
                request.httpBody = try? JSONSerialization.data(withJSONObject: body)

                URLSession.shared.dataTask(with: request) { data, response, error in
                    if let error = error {
                        completion(.failure(error))
                        return
                    }
                    guard let data = data else {
                        completion(.failure(NSError(domain: "NoData", code: 0, userInfo: nil)))
                        return
                    }
                    
                    // Check for authentication error
                    if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                        completion(.failure(NSError(domain: "AuthError", code: 401, userInfo: [NSLocalizedDescriptionKey: "Authentication failed"])))
                        return
                    }
                    
                    do {
                        let decodedResponse = try JSONDecoder().decode(GenerateUploadURLResponse.self, from: data)
                        
                        guard decodedResponse.success else {
                            completion(.failure(NSError(domain: "APIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "API returned failure"])))
                            return
                        }
                        
                        completion(.success(decodedResponse))
                    } catch {
                        if let responseString = String(data: data, encoding: .utf8) {
                            print("[API] Failed to decode JSON. Raw response: \(responseString)")
                        }
                        completion(.failure(error))
                    }
                }.resume()
            } catch {
                completion(.failure(error))
            }
        }
    }

    // 2. Upload file to Supabase using the signed URL
    private func uploadFile(to uploadUrl: String, fileURL: URL, completion: @escaping (Result<Void, Error>) -> Void) {
        print("[API] Uploading file to Supabase: \(fileURL)")
        guard let url = URL(string: uploadUrl) else {
            completion(.failure(NSError(domain: "InvalidURL", code: 1, userInfo: nil)))
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.setValue("audio/m4a", forHTTPHeaderField: "Content-Type")

        do {
            let audioData = try Data(contentsOf: fileURL)
            URLSession.shared.uploadTask(with: request, from: audioData) { data, response, error in
                if let error = error {
                    completion(.failure(error))
                    return
                }
                guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                    let statusCode = (response as? HTTPURLResponse)?.statusCode ?? -1
                    print("[API] Supabase upload failed with status code: \(statusCode)")
                    if let responseData = data, let responseString = String(data: responseData, encoding: .utf8) {
                        print("[API] Supabase error response: \(responseString)")
                    }
                    completion(.failure(NSError(domain: "UploadFailed", code: statusCode, userInfo: nil)))
                    return
                }
                print("[API] Supabase upload successful!")
                completion(.success(()))
            }.resume()
        } catch {
            completion(.failure(error))
        }
    }

    // 3. Start Transcription via backend
    private func startTranscription(filePath: String, completion: @escaping (Result<(String, [TranscriptSegment]), Error>) -> Void) {
        print("[API] Starting transcription for path: \(filePath)")
        
        Task {
            do {
                // Get authentication token
                let session = try await supabase.auth.session
                
                guard let url = URL(string: transcribeEndpoint) else {
                    completion(.failure(NSError(domain: "InvalidURL", code: 2, userInfo: nil)))
                    return
                }

                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
                let body = ["filePath": filePath]
                request.httpBody = try? JSONEncoder().encode(body)

                URLSession.shared.dataTask(with: request) { data, response, error in
                    if let error = error {
                        completion(.failure(error))
                        return
                    }
                    guard let data = data else {
                        completion(.failure(NSError(domain: "NoData", code: 0, userInfo: nil)))
                        return
                    }
                    
                    if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                        let statusCode = httpResponse.statusCode
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("[API] Transcription failed with status: \(statusCode), body: \(responseBody)")
                        completion(.failure(NSError(domain: "TranscriptionError", code: statusCode, userInfo: [NSLocalizedDescriptionKey: "Server error: \(responseBody)"])))
                        return
                    }
                    
                    do {
                        let decodedResponse = try JSONDecoder().decode(TranscribeResponse.self, from: data)
                        guard decodedResponse.success else {
                            completion(.failure(NSError(domain: "APIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "API returned failure"])))
                            return
                        }
                        
                        if decodedResponse.data.status == "completed" || decodedResponse.data.status == "success" {
                            let text = decodedResponse.data.text ?? ""
                            let segments = self.convertAssemblyAIWordsToTranscriptSegments(decodedResponse.data.segments)
                            completion(.success((text, segments)))
                        } else if decodedResponse.data.status == "queued" || decodedResponse.data.status == "processing" {
                            // Start polling
                            self.pollTranscriptionStatus(jobId: decodedResponse.data.id, attempt: 0, completion: completion)
                        } else {
                            completion(.failure(NSError(domain: "TranscriptionFailed", code: 0, userInfo: [NSLocalizedDescriptionKey: "Transcription did not complete. Status: \(decodedResponse.data.status)"])))
                        }
                    } catch {
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("[API] JSON Decoding Error: \(error.localizedDescription). Response: \(responseBody)")
                        completion(.failure(error))
                    }
                }.resume()
            } catch {
                completion(.failure(error))
            }
        }
    }

    // Polling logic for transcription status
    private func pollTranscriptionStatus(jobId: String, attempt: Int = 0, maxAttempts: Int = 40, pollInterval: TimeInterval = 3.0, completion: @escaping (Result<(String, [TranscriptSegment]), Error>) -> Void) {
        
        Task {
            do {
                // Get authentication token
                let session = try await supabase.auth.session
                
                guard let statusUrl = URL(string: "https://comfy-daffodil-7ecc55.netlify.app/api/transcribe-status") else {
                    completion(.failure(NSError(domain: "InvalidStatusURL", code: 0, userInfo: nil)))
                    return
                }
                var request = URLRequest(url: statusUrl)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
                let body = ["id": jobId]
                request.httpBody = try? JSONEncoder().encode(body)

                URLSession.shared.dataTask(with: request) { data, response, error in
                    if let error = error {
                        completion(.failure(error))
                        return
                    }
                    guard let data = data else {
                        completion(.failure(NSError(domain: "NoData", code: 0, userInfo: nil)))
                        return
                    }
                    do {
                        let decodedResponse = try JSONDecoder().decode(TranscribeResponse.self, from: data)
                        guard decodedResponse.success else {
                            completion(.failure(NSError(domain: "APIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "API returned failure"])))
                            return
                        }
                        
                        if decodedResponse.data.status == "completed" || decodedResponse.data.status == "success" {
                            let text = decodedResponse.data.text ?? ""
                            let segments = self.convertAssemblyAIWordsToTranscriptSegments(decodedResponse.data.segments)
                            completion(.success((text, segments)))
                        } else if decodedResponse.data.status == "failed" {
                            completion(.failure(NSError(domain: "TranscriptionFailed", code: 0, userInfo: [NSLocalizedDescriptionKey: "Transcription failed."])))
                        } else if attempt < maxAttempts {
                            DispatchQueue.main.asyncAfter(deadline: .now() + pollInterval) {
                                self.pollTranscriptionStatus(jobId: jobId, attempt: attempt + 1, maxAttempts: maxAttempts, pollInterval: pollInterval, completion: completion)
                            }
                        } else {
                            completion(.failure(NSError(domain: "Timeout", code: 0, userInfo: [NSLocalizedDescriptionKey: "Polling timed out."])))
                        }
                    } catch {
                        completion(.failure(error))
                    }
                }.resume()
            } catch {
                completion(.failure(error))
            }
        }
    }

    // Helper to convert AssemblyAIWord to TranscriptSegment, grouping by time gap
    private func convertAssemblyAIWordsToTranscriptSegments(_ words: [AssemblyAIWord]?) -> [TranscriptSegment] {
        guard let words = words, !words.isEmpty else { return [] }
        var segments: [TranscriptSegment] = []
        var currentWords: [AssemblyAIWord] = [words[0]]
        let gapThreshold: Double = 0.7 // seconds

        for i in 1..<words.count {
            let prev = words[i-1]
            let curr = words[i]
            let gap = Double(curr.start - prev.end) / 1000.0
            if gap > gapThreshold {
                // End current segment
                let text = currentWords.map { $0.text }.joined(separator: " ")
                let startTime = Double(currentWords.first!.start) / 1000.0
                let endTime = Double(currentWords.last!.end) / 1000.0
                segments.append(TranscriptSegment(text: text, startTime: startTime, endTime: endTime))
                currentWords = []
            }
            currentWords.append(curr)
        }
        // Add the last segment
        if !currentWords.isEmpty {
            let text = currentWords.map { $0.text }.joined(separator: " ")
            let startTime = Double(currentWords.first!.start) / 1000.0
            let endTime = Double(currentWords.last!.end) / 1000.0
            segments.append(TranscriptSegment(text: text, startTime: startTime, endTime: endTime))
        }
        return segments
    }

    // High-level function to transcribe a file using the backend with retry mechanism
    func transcribeAudioFile(url: URL, completion: @escaping (Result<(String, [TranscriptSegment]), Error>) -> Void) {
        transcribeAudioFileWithRetry(url: url, maxRetries: 3, currentAttempt: 1, completion: completion)
    }
    
    private func transcribeAudioFileWithRetry(url: URL, maxRetries: Int, currentAttempt: Int, completion: @escaping (Result<(String, [TranscriptSegment]), Error>) -> Void) {
        let fileName = url.lastPathComponent
        
        print("[API] Transcription attempt \(currentAttempt) of \(maxRetries) for \(fileName)")
        
        // Get file information
        do {
            let resourceValues = try url.resourceValues(forKeys: [.fileSizeKey])
            let fileSize = resourceValues.fileSize ?? 0
            
            // Determine content type from file extension
            let pathExtension = url.pathExtension.lowercased()
            let contentType: String
            switch pathExtension {
            case "m4a":
                contentType = "audio/m4a"
            case "mp3":
                contentType = "audio/mpeg"
            case "wav":
                contentType = "audio/wav"
            case "mp4":
                contentType = "audio/mp4"
            default:
                contentType = "audio/m4a" // Default fallback
            }
            
            getUploadURL(fileName: fileName, contentType: contentType, fileSize: fileSize) { result in
                switch result {
                case .success(let uploadInfo):
                    self.uploadFile(to: uploadInfo.data.uploadUrl, fileURL: url) { uploadResult in
                        switch uploadResult {
                        case .success:
                            self.startTranscription(filePath: uploadInfo.data.path) { transcriptionResult in
                                switch transcriptionResult {
                                case .success:
                                    completion(transcriptionResult)
                                case .failure(let error):
                                    self.handleTranscriptionError(error: error, url: url, maxRetries: maxRetries, currentAttempt: currentAttempt, completion: completion)
                                }
                            }
                        case .failure(let error):
                            print("[API] Upload failed: \(error.localizedDescription)")
                            self.handleTranscriptionError(error: error, url: url, maxRetries: maxRetries, currentAttempt: currentAttempt, completion: completion)
                        }
                    }
                case .failure(let error):
                    print("[API] GetUploadURL failed: \(error.localizedDescription)")
                    self.handleTranscriptionError(error: error, url: url, maxRetries: maxRetries, currentAttempt: currentAttempt, completion: completion)
                }
            }
        } catch {
            print("[API] Failed to get file information: \(error.localizedDescription)")
            completion(.failure(error))
        }
    }
    
    private func handleTranscriptionError(error: Error, url: URL, maxRetries: Int, currentAttempt: Int, completion: @escaping (Result<(String, [TranscriptSegment]), Error>) -> Void) {
        // Check if we should retry
        if currentAttempt < maxRetries && isRetryableError(error) {
            let retryDelay = calculateRetryDelay(attempt: currentAttempt)
            print("[API] Retrying transcription in \(retryDelay) seconds due to: \(error.localizedDescription)")
            
            DispatchQueue.main.asyncAfter(deadline: .now() + retryDelay) {
                self.transcribeAudioFileWithRetry(url: url, maxRetries: maxRetries, currentAttempt: currentAttempt + 1, completion: completion)
            }
        } else {
            // All retries exhausted or non-retryable error
            let enhancedError = self.createEnhancedError(from: error, attempt: currentAttempt, maxRetries: maxRetries)
            completion(.failure(enhancedError))
        }
    }
    
    private func isRetryableError(_ error: Error) -> Bool {
        // Network errors, timeouts, and server errors are retryable
        let nsError = error as NSError
        
        // Network connectivity issues
        if nsError.domain == NSURLErrorDomain {
            switch nsError.code {
            case NSURLErrorNotConnectedToInternet,
                 NSURLErrorNetworkConnectionLost,
                 NSURLErrorTimedOut,
                 NSURLErrorCannotConnectToHost,
                 NSURLErrorCannotFindHost,
                 NSURLErrorDNSLookupFailed:
                return true
            default:
                return false
            }
        }
        
        // Server errors (5xx status codes)
        if nsError.domain == "UploadFailed" || nsError.domain == "TranscriptionError" {
            let statusCode = nsError.code
            return statusCode >= 500 && statusCode < 600
        }
        
        // Circuit breaker and timeout errors
        if error.localizedDescription.contains("Circuit breaker") ||
           error.localizedDescription.contains("timed out") ||
           error.localizedDescription.contains("timeout") {
            return true
        }
        
        return false
    }
    
    private func calculateRetryDelay(attempt: Int) -> TimeInterval {
        // Exponential backoff: 2, 4, 8 seconds
        return TimeInterval(pow(2.0, Double(attempt)))
    }
    
    private func createEnhancedError(from error: Error, attempt: Int, maxRetries: Int) -> Error {
        let nsError = error as NSError
        var userInfo = nsError.userInfo
        
        // Create user-friendly error message
        let userMessage: String
        if nsError.domain == NSURLErrorDomain {
            switch nsError.code {
            case NSURLErrorNotConnectedToInternet:
                userMessage = "No internet connection. Please check your network and try again."
            case NSURLErrorNetworkConnectionLost:
                userMessage = "Network connection lost. Please check your connection and try again."
            case NSURLErrorTimedOut:
                userMessage = "Request timed out. Please try again with a better connection."
            default:
                userMessage = "Network error occurred. Please check your connection and try again."
            }
        } else if nsError.domain == "AuthError" {
            userMessage = "Authentication failed. Please sign in again and try again."
        } else if nsError.domain == "UploadFailed" {
            userMessage = "Failed to upload audio file. Please try again."
        } else if nsError.domain == "TranscriptionError" {
            userMessage = "Transcription service is temporarily unavailable. Please try again later."
        } else {
            userMessage = "Processing failed after \(maxRetries) attempts. Please try again later."
        }
        
        userInfo[NSLocalizedDescriptionKey] = userMessage
        userInfo["originalError"] = error.localizedDescription
        userInfo["attemptCount"] = attempt
        userInfo["maxRetries"] = maxRetries
        
        return NSError(domain: "TranscriptionServiceError", code: nsError.code, userInfo: userInfo)
    }
} 
