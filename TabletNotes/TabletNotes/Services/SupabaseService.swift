import Foundation
import Supabase

class SupabaseService: SupabaseServiceProtocol {
    static let shared = SupabaseService()

    private let supabase: SupabaseClient
    
    // Public access to Supabase client for authentication
    var client: SupabaseClient {
        return supabase
    }

    init() {
        guard let supabaseURL = URL(string: SupabaseConfig.url) else {
            fatalError("Invalid Supabase URL in configuration")
        }
        let supabaseKey = SupabaseConfig.anonKey
        
        self.supabase = SupabaseClient(supabaseURL: supabaseURL, supabaseKey: supabaseKey)
    }

    // Netlify API endpoint
    private let apiBaseUrl = "https://comfy-daffodil-7ecc55.netlify.app"
    
    /// Helper method to get auth token with automatic refresh and retry logic
    private func getAuthToken() async throws -> String {
        return try await NetworkRetry.withExponentialBackoff(maxAttempts: 2) {
            do {
                let session = try await self.supabase.auth.session
                return session.accessToken
            } catch {
                print("[SupabaseService] Session expired, attempting refresh...")
                do {
                    let refreshedSession = try await self.supabase.auth.refreshSession()
                    print("[SupabaseService] Token refreshed successfully")
                    return refreshedSession.accessToken
                } catch {
                    print("[SupabaseService] Token refresh failed: \(error.localizedDescription)")
                    throw URLError(.userAuthenticationRequired)
                }
            }
        }
    }

    struct SignedUploadURLResponse: Codable {
        let success: Bool
        let data: UploadURLData
        let timestamp: String
    }
    
    struct UploadURLData: Codable {
        let uploadUrl: String
        let path: String
        let token: String
        let userId: String
        let metadata: UploadMetadata?
    }
    
    struct UploadMetadata: Codable {
        let originalFileName: String
        let contentType: String
        let fileSize: Int
        let maxFileSize: Int
        let allowedTypes: [String]
    }

    /// Fetches a secure, one-time URL for uploading a file.
    /// - Parameters:
    ///   - fileName: The name of the file to be uploaded (e.g., "recording.m4a").
    ///   - contentType: The MIME type of the file (e.g., "audio/m4a").
    ///   - fileSize: The size of the file in bytes.
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileName: String, contentType: String, fileSize: Int) async throws -> (uploadUrl: URL, path: String) {
        print("[SupabaseService] getSignedUploadURL called for: \(fileName)")

        // Get authentication token with automatic refresh
        let accessToken = try await getAuthToken()
        print("[SupabaseService] Got auth token")

        let url = URL(string: "\(apiBaseUrl)/api/generate-upload-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

        let body = [
            "fileName": fileName,
            "contentType": contentType,
            "fileSize": fileSize,
            "filePath": "temp" // Placeholder - actual path is generated by function
        ] as [String : Any]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)
        request.timeoutInterval = 30 // 30 second timeout

        print("[SupabaseService] Calling generate-upload-url API...")
        let (data, response) = try await NetworkRetry.withExponentialBackoff {
            try await URLSession.shared.data(for: request)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            print("[SupabaseService] ‚ùå No HTTP response")
            throw URLError(.badServerResponse)
        }

        print("[SupabaseService] API response status: \(httpResponse.statusCode)")

        guard httpResponse.statusCode == 200 else {
            if let responseString = String(data: data, encoding: .utf8) {
                print("[SupabaseService] ‚ùå API error response: \(responseString)")
            }
            if httpResponse.statusCode == 401 {
                throw URLError(.userAuthenticationRequired)
            }
            throw URLError(.badServerResponse)
        }

        let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)

        guard decodedResponse.success else {
            print("[SupabaseService] ‚ùå Response success=false")
            throw URLError(.badServerResponse)
        }

        guard let uploadUrl = URL(string: decodedResponse.data.uploadUrl) else {
            print("[SupabaseService] ‚ùå Invalid upload URL")
            throw URLError(.badURL)
        }

        print("[SupabaseService] ‚úÖ Upload URL: \(uploadUrl)")
        print("[SupabaseService] ‚úÖ Path: \(decodedResponse.data.path)")

        return (uploadUrl, decodedResponse.data.path)
    }
    
    /// Convenience method that gets file information and requests an upload URL
    /// - Parameter fileURL: The local URL of the file to be uploaded
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileURL: URL) async throws -> (uploadUrl: URL, path: String) {
        // Get file attributes
        let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey, .contentTypeKey])
        let fileSize = resourceValues.fileSize ?? 0
        
        // Determine content type from file extension if not available
        let fileName = fileURL.lastPathComponent
        let contentType: String
        if let resourceContentType = resourceValues.contentType?.identifier {
            contentType = resourceContentType
        } else {
            // Fallback based on file extension
            let pathExtension = fileURL.pathExtension.lowercased()
            switch pathExtension {
            case "m4a":
                contentType = "audio/m4a"
            case "mp3":
                contentType = "audio/mpeg"
            case "wav":
                contentType = "audio/wav"
            case "mp4":
                contentType = "audio/mp4"
            default:
                contentType = "audio/m4a" // Default fallback
            }
        }
        
        return try await getSignedUploadURL(for: fileName, contentType: contentType, fileSize: fileSize)
    }

    /// Uploads the audio file from a local URL to the provided signed URL with retry logic.
    /// - Parameters:
    ///   - localUrl: The URL of the audio file on the device.
    ///   - signedUploadUrl: The secure, one-time URL obtained from `getSignedUploadURL`.
    func uploadAudioFile(at localUrl: URL, to signedUploadUrl: URL) async throws {
        let audioData = try Data(contentsOf: localUrl)

        try await NetworkRetry.withExponentialBackoff(maxAttempts: 3) {
            var request = URLRequest(url: signedUploadUrl)
            request.httpMethod = "PUT"
            request.setValue("audio/m4a", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = 60 // 60 second timeout for uploads

            // Create a configured URLSession for large uploads
            let config = URLSessionConfiguration.default
            config.timeoutIntervalForRequest = 60
            config.timeoutIntervalForResource = 300 // 5 minutes for large files
            config.waitsForConnectivity = true // Wait for network if unavailable
            let session = URLSession(configuration: config)

            let (_, response) = try await session.upload(for: request, from: audioData)

            guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                throw URLError(.badServerResponse)
            }
        }
    }
    
    /// Generic file upload method for protocol conformance with retry logic
    func uploadFile(data: Data, to uploadUrl: URL) async throws {
        try await NetworkRetry.withExponentialBackoff(maxAttempts: 3) {
            var request = URLRequest(url: uploadUrl)
            request.httpMethod = "PUT"
            request.setValue("application/octet-stream", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = 60

            // Create a configured URLSession
            let config = URLSessionConfiguration.default
            config.timeoutIntervalForRequest = 60
            config.timeoutIntervalForResource = 300
            config.waitsForConnectivity = true
            let session = URLSession(configuration: config)

            let (_, response) = try await session.upload(for: request, from: data)

            guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                throw URLError(.badServerResponse)
            }
        }
    }
    
    /// Gets a signed download URL for a file
    func getSignedDownloadURL(for path: String) async throws -> URL {
        print("[SupabaseService] Requesting download URL for path: \(path)")
        
        let url = URL(string: "\(apiBaseUrl)/api/generate-download-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token with automatic refresh
        let accessToken = try await getAuthToken()
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

        let body = ["path": path]
        request.httpBody = try JSONEncoder().encode(body)
        request.timeoutInterval = 30

        let (data, response) = try await NetworkRetry.withExponentialBackoff {
            try await URLSession.shared.data(for: request)
        }
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("[SupabaseService] Invalid response type for download URL")
            throw URLError(.badServerResponse)
        }
        
        print("[SupabaseService] Download URL response status: \(httpResponse.statusCode)")
        
        if httpResponse.statusCode != 200 {
            print("[SupabaseService] Download URL request failed with status: \(httpResponse.statusCode)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("[SupabaseService] Error response: \(responseString)")
            }
            throw URLError(.badServerResponse)
        }

        do {
            let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)
            
            guard decodedResponse.success else {
                print("[SupabaseService] Download URL API returned success: false")
                throw URLError(.badServerResponse)
            }
            
            guard let downloadUrl = URL(string: decodedResponse.data.uploadUrl) else {
                print("[SupabaseService] Invalid download URL: \(decodedResponse.data.uploadUrl)")
                throw URLError(.badURL)
            }
            
            print("[SupabaseService] Generated download URL: \(downloadUrl)")
            return downloadUrl
        } catch {
            print("[SupabaseService] Failed to decode download URL response: \(error)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("[SupabaseService] Raw response: \(responseString)")
            }
            throw error
        }
    }
    
    /// Updates user profile in Supabase
    func updateUserProfile(_ user: User) async throws {
        let url = URL(string: "\(apiBaseUrl)/api/update-profile")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token with automatic refresh
        let accessToken = try await getAuthToken()
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

        // Create update payload
        let updateData: [String: Any] = [
            "id": user.id.uuidString,
            "subscription_tier": user.subscriptionTier,
            "subscription_status": user.subscriptionStatus,
            "subscription_expiry": user.subscriptionExpiry?.ISO8601Format() ?? NSNull(),
            "subscription_product_id": user.subscriptionProductId ?? NSNull(),
            "subscription_purchase_date": user.subscriptionPurchaseDate?.ISO8601Format() ?? NSNull(),
            "subscription_renewal_date": user.subscriptionRenewalDate?.ISO8601Format() ?? NSNull(),
            "monthly_recording_count": user.monthlyRecordingCount,
            "monthly_recording_minutes": user.monthlyRecordingMinutes,
            "current_storage_used_gb": user.currentStorageUsedGB,
            "monthly_export_count": user.monthlyExportCount,
            "last_usage_reset_date": user.lastUsageResetDate?.ISO8601Format() ?? NSNull()
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: updateData)
        request.timeoutInterval = 30

        let (_, response) = try await NetworkRetry.withExponentialBackoff {
            try await URLSession.shared.data(for: request)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }

        guard httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
    }

    /// Downloads an audio file from Supabase storage to a local URL
    func downloadAudioFile(filename: String, localURL: URL, remotePath: String? = nil) async throws -> URL {
        print("[SupabaseService] Downloading file directly from Supabase storage: \(filename)")
        if let remotePath = remotePath {
            print("[SupabaseService] Using stored remote path: \(remotePath)")
        }
        
        // Try different bucket names and paths
        let bucketOptions = ["sermon-audio", "audio-recordings", "audio-files", "recordings"]
        
        var pathOptions: [String] = []
        
        // If we have the remote path, try it first
        if let remotePath = remotePath {
            pathOptions.append(remotePath)
        }
        
        
        // Add fallback paths
        pathOptions.append(contentsOf: [
            filename,
            "audio-files/\(filename)",
            "recordings/\(filename)"
        ])
        
        // Add user-specific path if we can get the current user
        do {
            // Get auth token first (with refresh), then get session for user ID
            _ = try await getAuthToken()
            let session = try await supabase.auth.session
            let userId = session.user.id
            pathOptions.append("\(userId)/\(filename)")
            pathOptions.append("audio-files/\(userId)/\(filename)")
        } catch {
            print("[SupabaseService] Could not get user session for path construction: \(error)")
        }
        
        for bucket in bucketOptions {
            for path in pathOptions {
                do {
                    print("[SupabaseService] Trying bucket: \(bucket), path: \(path)")
                    
                    // Use Supabase SDK directly to download the file
                    let data = try await supabase.storage
                        .from(bucket)
                        .download(path: path)
                    
                    print("[SupabaseService] Downloaded \(data.count) bytes from bucket: \(bucket), path: \(path)")
                    
                    // Ensure the directory exists
                    let directory = localURL.deletingLastPathComponent()
                    try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true, attributes: nil)
                    
                    // Write the file to local storage
                    try data.write(to: localURL)
                    
                    print("[SupabaseService] Successfully downloaded audio file from \(bucket)/\(path) to \(localURL)")
                    return localURL
                } catch {
                    print("[SupabaseService] Failed to download from bucket: \(bucket), path: \(path) - \(error)")
                    // Continue to next option
                }
            }
        }
        
        // If all options failed, throw the last error
        throw URLError(.fileDoesNotExist)
    }

    /// Fetches all remote sermons for a user from the Netlify API
    func fetchRemoteSermons(for userId: UUID) async throws -> [RemoteSermonData] {
        print("[SupabaseService] fetchRemoteSermons called for userId: \(userId.uuidString)")

        let url = URL(string: "\(apiBaseUrl)/api/get-sermons?userId=\(userId.uuidString)")!
        print("[SupabaseService] API URL: \(url.absoluteString)")

        var request = URLRequest(url: url)
        request.httpMethod = "GET"

        // Get authentication token with automatic refresh
        let accessToken = try await getAuthToken()
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.timeoutInterval = 30
        print("[SupabaseService] Request configured with auth token")

        let (data, response) = try await NetworkRetry.withExponentialBackoff {
            try await URLSession.shared.data(for: request)
        }

        // Log raw response
        if let jsonString = String(data: data, encoding: .utf8) {
            print("[SupabaseService] üì¶ Raw JSON response: \(jsonString)")
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            print("[SupabaseService] ‚ùå Response is not HTTPURLResponse")
            throw URLError(.badServerResponse)
        }

        print("[SupabaseService] HTTP Status: \(httpResponse.statusCode)")

        guard httpResponse.statusCode == 200 else {
            print("[SupabaseService] ‚ùå Bad status code: \(httpResponse.statusCode)")
            throw URLError(.badServerResponse)
        }

        // Decode the wrapped response: {"success": true, "data": [...]}
        print("[SupabaseService] Attempting to decode JSON...")
        let decoder = JSONDecoder()

        // Custom date decoder to handle multiple ISO8601 formats including +00:00 timezone
        decoder.dateDecodingStrategy = .custom { decoder in
            let container = try decoder.singleValueContainer()
            let dateString = try container.decode(String.self)

            // Try multiple ISO8601 formats
            let formatters = [
                ISO8601DateFormatter(), // Standard: 2025-11-02T19:54:30Z
                {
                    let formatter = ISO8601DateFormatter()
                    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    return formatter
                }(), // With fractional seconds
                {
                    let formatter = DateFormatter()
                    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ" // Handles +00:00
                    formatter.locale = Locale(identifier: "en_US_POSIX")
                    formatter.timeZone = TimeZone(secondsFromGMT: 0)
                    return formatter
                }()
            ]

            for formatter in formatters {
                if let iso8601Formatter = formatter as? ISO8601DateFormatter,
                   let date = iso8601Formatter.date(from: dateString) {
                    return date
                } else if let dateFormatter = formatter as? DateFormatter,
                          let date = dateFormatter.date(from: dateString) {
                    return date
                }
            }

            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Cannot decode date string: \(dateString)")
        }

        do {
            // First decode as dictionary to extract the "data" array
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let sermonsArray = json["data"] as? [[String: Any]] else {
                print("[SupabaseService] ‚ùå Failed to extract data array from response")
                throw URLError(.cannotParseResponse)
            }

            // Re-encode the sermons array and decode as [RemoteSermonData]
            let sermonsData = try JSONSerialization.data(withJSONObject: sermonsArray)
            let sermons = try decoder.decode([RemoteSermonData].self, from: sermonsData)
            print("[SupabaseService] ‚úÖ Successfully decoded \(sermons.count) sermons")
            return sermons
        } catch {
            print("[SupabaseService] ‚ùå JSON decode error: \(error)")
            throw error
        }
    }
} 
