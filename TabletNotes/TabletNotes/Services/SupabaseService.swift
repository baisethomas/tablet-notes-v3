import Foundation
import Supabase

class SupabaseService: SupabaseServiceProtocol {
    static let shared = SupabaseService()

    private let supabase: SupabaseClient
    
    // Public access to Supabase client for authentication
    var client: SupabaseClient {
        return supabase
    }

    init() {
        guard let supabaseURL = URL(string: SupabaseConfig.url) else {
            fatalError("Invalid Supabase URL in configuration")
        }
        let supabaseKey = SupabaseConfig.anonKey
        
        self.supabase = SupabaseClient(supabaseURL: supabaseURL, supabaseKey: supabaseKey)
    }

    // Netlify API endpoint
    private let apiBaseUrl = "https://comfy-daffodil-7ecc55.netlify.app"

    struct SignedUploadURLResponse: Codable {
        let uploadUrl: String
        let path: String
        let token: String
    }

    /// Fetches a secure, one-time URL for uploading a file.
    /// - Parameters:
    ///   - fileName: The name of the file to be uploaded (e.g., "recording.m4a").
    ///   - contentType: The MIME type of the file (e.g., "audio/m4a").
    ///   - fileSize: The size of the file in bytes.
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileName: String, contentType: String, fileSize: Int) async throws -> (uploadUrl: URL, path: String) {
        // Get authentication token
        let session = try await supabase.auth.session
        
        let url = URL(string: "\(apiBaseUrl)/api/generate-upload-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        let body = [
            "fileName": fileName,
            "contentType": contentType,
            "fileSize": fileSize,
            "filePath": "temp" // Placeholder - actual path is generated by function
        ] as [String : Any]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        guard httpResponse.statusCode == 200 else {
            if httpResponse.statusCode == 401 {
                throw URLError(.userAuthenticationRequired)
            }
            throw URLError(.badServerResponse)
        }

        let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)
        guard let uploadUrl = URL(string: decodedResponse.uploadUrl) else {
            throw URLError(.badURL)
        }
        
        return (uploadUrl, decodedResponse.path)
    }
    
    /// Convenience method that gets file information and requests an upload URL
    /// - Parameter fileURL: The local URL of the file to be uploaded
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileURL: URL) async throws -> (uploadUrl: URL, path: String) {
        // Get file attributes
        let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey, .contentTypeKey])
        let fileSize = resourceValues.fileSize ?? 0
        
        // Determine content type from file extension if not available
        let fileName = fileURL.lastPathComponent
        let contentType: String
        if let resourceContentType = resourceValues.contentType?.identifier {
            contentType = resourceContentType
        } else {
            // Fallback based on file extension
            let pathExtension = fileURL.pathExtension.lowercased()
            switch pathExtension {
            case "m4a":
                contentType = "audio/m4a"
            case "mp3":
                contentType = "audio/mpeg"
            case "wav":
                contentType = "audio/wav"
            case "mp4":
                contentType = "audio/mp4"
            default:
                contentType = "audio/m4a" // Default fallback
            }
        }
        
        return try await getSignedUploadURL(for: fileName, contentType: contentType, fileSize: fileSize)
    }

    /// Uploads the audio file from a local URL to the provided signed URL.
    /// - Parameters:
    ///   - localUrl: The URL of the audio file on the device.
    ///   - signedUploadUrl: The secure, one-time URL obtained from `getSignedUploadURL`.
    func uploadAudioFile(at localUrl: URL, to signedUploadUrl: URL) async throws {
        let audioData = try Data(contentsOf: localUrl)
        
        var request = URLRequest(url: signedUploadUrl)
        request.httpMethod = "PUT"
        request.setValue("audio/m4a", forHTTPHeaderField: "Content-Type") // Adjust if you use a different format

        let (_, response) = try await URLSession.shared.upload(for: request, from: audioData)

        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
    }
    
    /// Generic file upload method for protocol conformance
    func uploadFile(data: Data, to uploadUrl: URL) async throws {
        var request = URLRequest(url: uploadUrl)
        request.httpMethod = "PUT"
        request.setValue("application/octet-stream", forHTTPHeaderField: "Content-Type")

        let (_, response) = try await URLSession.shared.upload(for: request, from: data)

        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
    }
    
    /// Gets a signed download URL for a file
    func getSignedDownloadURL(for path: String) async throws -> URL {
        let url = URL(string: "\(apiBaseUrl)/api/generate-download-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        let body = ["path": path]
        request.httpBody = try JSONEncoder().encode(body)

        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        guard httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }

        let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)
        guard let downloadUrl = URL(string: decodedResponse.uploadUrl) else {
            throw URLError(.badURL)
        }
        
        return downloadUrl
    }
    
    /// Updates user profile in Supabase
    func updateUserProfile(_ user: User) async throws {
        let url = URL(string: "\(apiBaseUrl)/api/update-profile")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        // Create update payload
        let updateData: [String: Any] = [
            "id": user.id.uuidString,
            "subscription_tier": user.subscriptionTier,
            "subscription_status": user.subscriptionStatus,
            "subscription_expiry": user.subscriptionExpiry?.ISO8601Format() ?? NSNull(),
            "subscription_product_id": user.subscriptionProductId ?? NSNull(),
            "subscription_purchase_date": user.subscriptionPurchaseDate?.ISO8601Format() ?? NSNull(),
            "subscription_renewal_date": user.subscriptionRenewalDate?.ISO8601Format() ?? NSNull(),
            "monthly_recording_count": user.monthlyRecordingCount,
            "monthly_recording_minutes": user.monthlyRecordingMinutes,
            "current_storage_used_gb": user.currentStorageUsedGB,
            "monthly_export_count": user.monthlyExportCount,
            "last_usage_reset_date": user.lastUsageResetDate?.ISO8601Format() ?? NSNull()
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: updateData)

        let (_, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        guard httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
    }

    /// Fetches all remote sermons for a user from the Netlify API
    func fetchRemoteSermons(for userId: UUID) async throws -> [RemoteSermonData] {
        let url = URL(string: "\(apiBaseUrl)/api/get-sermons?userId=\(userId.uuidString)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
        // Decode the array of RemoteSermonData
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let sermons = try decoder.decode([RemoteSermonData].self, from: data)
        return sermons
    }
} 
