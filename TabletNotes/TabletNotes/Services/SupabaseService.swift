import Foundation
import Supabase

class SupabaseService: SupabaseServiceProtocol {
    static let shared = SupabaseService()

    private let supabase: SupabaseClient
    
    // Public access to Supabase client for authentication
    var client: SupabaseClient {
        return supabase
    }

    init() {
        guard let supabaseURL = URL(string: SupabaseConfig.url) else {
            fatalError("Invalid Supabase URL in configuration")
        }
        let supabaseKey = SupabaseConfig.anonKey
        
        self.supabase = SupabaseClient(supabaseURL: supabaseURL, supabaseKey: supabaseKey)
    }

    // Netlify API endpoint
    private let apiBaseUrl = "https://comfy-daffodil-7ecc55.netlify.app"

    struct SignedUploadURLResponse: Codable {
        let success: Bool
        let data: UploadURLData
        let timestamp: String
    }
    
    struct UploadURLData: Codable {
        let uploadUrl: String
        let path: String
        let token: String
        let userId: String
        let metadata: UploadMetadata?
    }
    
    struct UploadMetadata: Codable {
        let originalFileName: String
        let contentType: String
        let fileSize: Int
        let maxFileSize: Int
        let allowedTypes: [String]
    }

    /// Fetches a secure, one-time URL for uploading a file.
    /// - Parameters:
    ///   - fileName: The name of the file to be uploaded (e.g., "recording.m4a").
    ///   - contentType: The MIME type of the file (e.g., "audio/m4a").
    ///   - fileSize: The size of the file in bytes.
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileName: String, contentType: String, fileSize: Int) async throws -> (uploadUrl: URL, path: String) {
        // Get authentication token
        let session = try await supabase.auth.session
        
        let url = URL(string: "\(apiBaseUrl)/api/generate-upload-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        let body = [
            "fileName": fileName,
            "contentType": contentType,
            "fileSize": fileSize,
            "filePath": "temp" // Placeholder - actual path is generated by function
        ] as [String : Any]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        guard httpResponse.statusCode == 200 else {
            if httpResponse.statusCode == 401 {
                throw URLError(.userAuthenticationRequired)
            }
            throw URLError(.badServerResponse)
        }

        let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)
        
        guard decodedResponse.success else {
            throw URLError(.badServerResponse)
        }
        
        guard let uploadUrl = URL(string: decodedResponse.data.uploadUrl) else {
            throw URLError(.badURL)
        }
        
        return (uploadUrl, decodedResponse.data.path)
    }
    
    /// Convenience method that gets file information and requests an upload URL
    /// - Parameter fileURL: The local URL of the file to be uploaded
    /// - Returns: A tuple containing the signed URL for the upload and the file's permanent path in the bucket.
    func getSignedUploadURL(for fileURL: URL) async throws -> (uploadUrl: URL, path: String) {
        // Get file attributes
        let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey, .contentTypeKey])
        let fileSize = resourceValues.fileSize ?? 0
        
        // Determine content type from file extension if not available
        let fileName = fileURL.lastPathComponent
        let contentType: String
        if let resourceContentType = resourceValues.contentType?.identifier {
            contentType = resourceContentType
        } else {
            // Fallback based on file extension
            let pathExtension = fileURL.pathExtension.lowercased()
            switch pathExtension {
            case "m4a":
                contentType = "audio/m4a"
            case "mp3":
                contentType = "audio/mpeg"
            case "wav":
                contentType = "audio/wav"
            case "mp4":
                contentType = "audio/mp4"
            default:
                contentType = "audio/m4a" // Default fallback
            }
        }
        
        return try await getSignedUploadURL(for: fileName, contentType: contentType, fileSize: fileSize)
    }

    /// Uploads the audio file from a local URL to the provided signed URL.
    /// - Parameters:
    ///   - localUrl: The URL of the audio file on the device.
    ///   - signedUploadUrl: The secure, one-time URL obtained from `getSignedUploadURL`.
    func uploadAudioFile(at localUrl: URL, to signedUploadUrl: URL) async throws {
        let audioData = try Data(contentsOf: localUrl)
        
        var request = URLRequest(url: signedUploadUrl)
        request.httpMethod = "PUT"
        request.setValue("audio/m4a", forHTTPHeaderField: "Content-Type") // Adjust if you use a different format

        let (_, response) = try await URLSession.shared.upload(for: request, from: audioData)

        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
    }
    
    /// Generic file upload method for protocol conformance
    func uploadFile(data: Data, to uploadUrl: URL) async throws {
        var request = URLRequest(url: uploadUrl)
        request.httpMethod = "PUT"
        request.setValue("application/octet-stream", forHTTPHeaderField: "Content-Type")

        let (_, response) = try await URLSession.shared.upload(for: request, from: data)

        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
    }
    
    /// Gets a signed download URL for a file
    func getSignedDownloadURL(for path: String) async throws -> URL {
        print("[SupabaseService] Requesting download URL for path: \(path)")
        
        let url = URL(string: "\(apiBaseUrl)/api/generate-download-url")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        let body = ["path": path]
        request.httpBody = try JSONEncoder().encode(body)

        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("[SupabaseService] Invalid response type for download URL")
            throw URLError(.badServerResponse)
        }
        
        print("[SupabaseService] Download URL response status: \(httpResponse.statusCode)")
        
        if httpResponse.statusCode != 200 {
            print("[SupabaseService] Download URL request failed with status: \(httpResponse.statusCode)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("[SupabaseService] Error response: \(responseString)")
            }
            throw URLError(.badServerResponse)
        }

        do {
            let decodedResponse = try JSONDecoder().decode(SignedUploadURLResponse.self, from: data)
            
            guard decodedResponse.success else {
                print("[SupabaseService] Download URL API returned success: false")
                throw URLError(.badServerResponse)
            }
            
            guard let downloadUrl = URL(string: decodedResponse.data.uploadUrl) else {
                print("[SupabaseService] Invalid download URL: \(decodedResponse.data.uploadUrl)")
                throw URLError(.badURL)
            }
            
            print("[SupabaseService] Generated download URL: \(downloadUrl)")
            return downloadUrl
        } catch {
            print("[SupabaseService] Failed to decode download URL response: \(error)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("[SupabaseService] Raw response: \(responseString)")
            }
            throw error
        }
    }
    
    /// Updates user profile in Supabase
    func updateUserProfile(_ user: User) async throws {
        let url = URL(string: "\(apiBaseUrl)/api/update-profile")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")

        // Create update payload
        let updateData: [String: Any] = [
            "id": user.id.uuidString,
            "subscription_tier": user.subscriptionTier,
            "subscription_status": user.subscriptionStatus,
            "subscription_expiry": user.subscriptionExpiry?.ISO8601Format() ?? NSNull(),
            "subscription_product_id": user.subscriptionProductId ?? NSNull(),
            "subscription_purchase_date": user.subscriptionPurchaseDate?.ISO8601Format() ?? NSNull(),
            "subscription_renewal_date": user.subscriptionRenewalDate?.ISO8601Format() ?? NSNull(),
            "monthly_recording_count": user.monthlyRecordingCount,
            "monthly_recording_minutes": user.monthlyRecordingMinutes,
            "current_storage_used_gb": user.currentStorageUsedGB,
            "monthly_export_count": user.monthlyExportCount,
            "last_usage_reset_date": user.lastUsageResetDate?.ISO8601Format() ?? NSNull()
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: updateData)

        let (_, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        guard httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
    }

    /// Downloads an audio file from Supabase storage to a local URL
    func downloadAudioFile(filename: String, localURL: URL, remotePath: String? = nil) async throws -> URL {
        print("[SupabaseService] Downloading file directly from Supabase storage: \(filename)")
        if let remotePath = remotePath {
            print("[SupabaseService] Using stored remote path: \(remotePath)")
        }
        
        // Try different bucket names and paths
        let bucketOptions = ["audio-recordings", "audio-files", "recordings"]
        
        var pathOptions: [String] = []
        
        // If we have the remote path, try it first
        if let remotePath = remotePath {
            pathOptions.append(remotePath)
        }
        
        
        // Add fallback paths
        pathOptions.append(contentsOf: [
            filename,
            "audio-files/\(filename)",
            "recordings/\(filename)"
        ])
        
        // Add user-specific path if we can get the current user
        do {
            let session = try await supabase.auth.session
            let userId = session.user.id
            pathOptions.append("\(userId)/\(filename)")
            pathOptions.append("audio-files/\(userId)/\(filename)")
        } catch {
            print("[SupabaseService] Could not get user session for path construction: \(error)")
        }
        
        for bucket in bucketOptions {
            for path in pathOptions {
                do {
                    print("[SupabaseService] Trying bucket: \(bucket), path: \(path)")
                    
                    // Use Supabase SDK directly to download the file
                    let data = try await supabase.storage
                        .from(bucket)
                        .download(path: path)
                    
                    print("[SupabaseService] Downloaded \(data.count) bytes from bucket: \(bucket), path: \(path)")
                    
                    // Ensure the directory exists
                    let directory = localURL.deletingLastPathComponent()
                    try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true, attributes: nil)
                    
                    // Write the file to local storage
                    try data.write(to: localURL)
                    
                    print("[SupabaseService] Successfully downloaded audio file from \(bucket)/\(path) to \(localURL)")
                    return localURL
                } catch {
                    print("[SupabaseService] Failed to download from bucket: \(bucket), path: \(path) - \(error)")
                    // Continue to next option
                }
            }
        }
        
        // If all options failed, throw the last error
        throw URLError(.fileDoesNotExist)
    }

    /// Fetches all remote sermons for a user from the Netlify API
    func fetchRemoteSermons(for userId: UUID) async throws -> [RemoteSermonData] {
        let url = URL(string: "\(apiBaseUrl)/api/get-sermons?userId=\(userId.uuidString)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        // Get authentication token
        let session = try await supabase.auth.session
        request.setValue("Bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }
        // Decode the array of RemoteSermonData
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let sermons = try decoder.decode([RemoteSermonData].self, from: data)
        return sermons
    }
} 
